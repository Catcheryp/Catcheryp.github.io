[{"categories":["Burpsuite"],"content":"Burp 宏使用的一些总结，记录一些常用操作。 ","date":"2024-03-21","objectID":"/posts/%E5%AE%89%E5%85%A8/burp-%E5%AE%8F/:0:0","tags":["burpsuite"],"title":"Burp 宏总结","uri":"/posts/%E5%AE%89%E5%85%A8/burp-%E5%AE%8F/"},{"categories":["Burpsuite"],"content":"从一个靶场开始 Lab: 2FA bypass using a brute-force attack | Web Security Academy 这里涉及到三个请求（前3个请求） GET /login：登录页面 POST /login：需要上一步页面中的csrf token进行该请求 GET /login2：需要上一步响应中的cookie进行这一步的请求 POST /login2：需要上一步中的csrf token，同时爆破这一步中的4位验证码。 burp macro只用执行前三步的操作即可 爆破需要使用单线程，靶场的爆破很慢，一共尝试10000次，大概在1000多次的时候就会成功 ","date":"2024-03-21","objectID":"/posts/%E5%AE%89%E5%85%A8/burp-%E5%AE%8F/:1:0","tags":["burpsuite"],"title":"Burp 宏总结","uri":"/posts/%E5%AE%89%E5%85%A8/burp-%E5%AE%8F/"},{"categories":["Burpsuite"],"content":"添加宏 ","date":"2024-03-21","objectID":"/posts/%E5%AE%89%E5%85%A8/burp-%E5%AE%8F/:1:1","tags":["burpsuite"],"title":"Burp 宏总结","uri":"/posts/%E5%AE%89%E5%85%A8/burp-%E5%AE%8F/"},{"categories":["Burpsuite"],"content":"使用宏 只需要更新请求中的csrf参数即可 确定宏的使用范围 ","date":"2024-03-21","objectID":"/posts/%E5%AE%89%E5%85%A8/burp-%E5%AE%8F/:1:2","tags":["burpsuite"],"title":"Burp 宏总结","uri":"/posts/%E5%AE%89%E5%85%A8/burp-%E5%AE%8F/"},{"categories":["Burpsuite"],"content":"在intruder中使用 注意将并发数修改为1，找到响应码是302的，让响应在浏览器中显示即可。 这里我爆破到4000多也没有爆破出来正确的验证码。这也接近真实的情况吧。 ","date":"2024-03-21","objectID":"/posts/%E5%AE%89%E5%85%A8/burp-%E5%AE%8F/:1:3","tags":["burpsuite"],"title":"Burp 宏总结","uri":"/posts/%E5%AE%89%E5%85%A8/burp-%E5%AE%8F/"},{"categories":["Burpsuite"],"content":"参考 使用 BurpSuite 宏获取 CSRF TOKEN | r0yanx’s Blog ","date":"2024-03-21","objectID":"/posts/%E5%AE%89%E5%85%A8/burp-%E5%AE%8F/:2:0","tags":["burpsuite"],"title":"Burp 宏总结","uri":"/posts/%E5%AE%89%E5%85%A8/burp-%E5%AE%8F/"},{"categories":["Burpsuite"],"content":"Burp Intruder总结，记录一些Tips和常用操作。 基于 Exploiting NoSQL operator injection to extract unknown fields 靶场来介绍 intruder 的功能，该靶场的详解见这里。 ","date":"2024-03-20","objectID":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/:0:0","tags":["burpsuite"],"title":"Burp Intruder总结","uri":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/"},{"categories":["Burpsuite"],"content":"四种爆破模式 这里假设有两个位置需要爆破。 ","date":"2024-03-20","objectID":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/:1:0","tags":["burpsuite"],"title":"Burp Intruder总结","uri":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/"},{"categories":["Burpsuite"],"content":"Sniper 第1个和第2个位置只能共用一个字典，假设字典中3个值 先暴破第1个位置3次，第2个位置不变 暴破第2个位置3次，第1个位置不变 共暴破6次 ","date":"2024-03-20","objectID":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/:1:1","tags":["burpsuite"],"title":"Burp Intruder总结","uri":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/"},{"categories":["Burpsuite"],"content":"Battering ram 第1个和第2个位置只能共用一个字典，假设字典中3个值 第1个位置和第2个位置同时暴破，每次使用相同的值 共暴破3次 ","date":"2024-03-20","objectID":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/:1:2","tags":["burpsuite"],"title":"Burp Intruder总结","uri":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/"},{"categories":["Burpsuite"],"content":"Pitchfork 第1个位置和第2个位置可以使用不同的字典 假设第1个位置字典值为3个（1、2、3），第2个位置为4个（a、b、c、d） 两个位置同时从各自字典的第1个值开始暴破 暴破次数为min(len(第1个字典), len(第2个字典)) ","date":"2024-03-20","objectID":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/:1:3","tags":["burpsuite"],"title":"Burp Intruder总结","uri":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/"},{"categories":["Burpsuite"],"content":"Cluster bomb 第1个位置和第2个位置可以使用不同的字典 假设第1个位置字典值为3个（1、2、3），第2个位置为4个（a、b、c、d） 两个位置同时进行暴破，类似使用全排列的方式进行暴破 共暴破3*4=12次 ","date":"2024-03-20","objectID":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/:1:4","tags":["burpsuite"],"title":"Burp Intruder总结","uri":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/"},{"categories":["Burpsuite"],"content":"常用内置字典 这里有很多常用的字典 ","date":"2024-03-20","objectID":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/:2:0","tags":["burpsuite"],"title":"Burp Intruder总结","uri":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/"},{"categories":["Burpsuite"],"content":"结果排序 先点击一下Payload1，再点击Length。就会在按Payload1排序的前提下，再按照Length排序。 ","date":"2024-03-20","objectID":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/:3:0","tags":["burpsuite"],"title":"Burp Intruder总结","uri":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/"},{"categories":["Burpsuite"],"content":"提取特定响应内容 直接鼠标选中即可 这里涉及到一个问题，如果响应的页面是302，而我们想提取的是302跳转之后的页面，那么只需要选中下面即可。 然后点击Refetch response，那么就会返回302跳转之后的页面响应内容。 ","date":"2024-03-20","objectID":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/:4:0","tags":["burpsuite"],"title":"Burp Intruder总结","uri":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/"},{"categories":["Burpsuite"],"content":"保存响应结果 这里我需要保存payload2为token ","date":"2024-03-20","objectID":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/:5:0","tags":["burpsuite"],"title":"Burp Intruder总结","uri":"/posts/%E5%AE%89%E5%85%A8/burp-intruder/"},{"categories":["折腾"],"content":"我的RSS信息输入源、工具和方式。 ","date":"2023-11-27","objectID":"/posts/%E6%8A%98%E8%85%BE/rss/:0:0","tags":["RSS","信息"],"title":"RSS信息源","uri":"/posts/%E6%8A%98%E8%85%BE/rss/"},{"categories":["折腾"],"content":"更新方案（2024.3.14） 1、inoreader pro（土区订阅2000里拉，约500元/年） 2、RSSHUB 3、RSSEverything– 开始收费了，10个/年：49元 4、公众号转RSS： 今天看啥 - 微信公众号rss订阅, 微信rss cooderl/wewe-rss: 🤗更优雅的微信公众号订阅方式，支持私有化部署、微信公众号RSS生成（基于微信读书）。（存在隐私泄露的风险） wechat2rss（主） Wechat2RSS:架构演进 | 明天的乌云 摸鱼百分百-tel群（辅） P神的星球Sec-News（辅） 5、后面的可以不用看 ","date":"2023-11-27","objectID":"/posts/%E6%8A%98%E8%85%BE/rss/:1:0","tags":["RSS","信息"],"title":"RSS信息源","uri":"/posts/%E6%8A%98%E8%85%BE/rss/"},{"categories":["折腾"],"content":"原来的方式 inoreader(pro套餐，贼拉贵) ，主要pro套餐包含20个web源的订阅 rsscatcheryp：自建的rsshub feed43：已关闭 WeRSS：公众号转RSS，略贵，刚开始还行，现在不咋地了 貌似是因为使用了黑五的优惠，导致不能以19.99$的价格续费了，真是无语啊。 ","date":"2023-11-27","objectID":"/posts/%E6%8A%98%E8%85%BE/rss/:2:0","tags":["RSS","信息"],"title":"RSS信息源","uri":"/posts/%E6%8A%98%E8%85%BE/rss/"},{"categories":["折腾"],"content":"现在的方式 inoreader的基础套餐 RSSEverything (主) PolitePol（辅:可以点击选择） P神的星球Sec-News（微信公众号转RSS） ","date":"2023-11-27","objectID":"/posts/%E6%8A%98%E8%85%BE/rss/:3:0","tags":["RSS","信息"],"title":"RSS信息源","uri":"/posts/%E6%8A%98%E8%85%BE/rss/"},{"categories":["折腾"],"content":"RSSEverything 免费，刷新速度还不错，下面是跟Feed43对比 ","date":"2023-11-27","objectID":"/posts/%E6%8A%98%E8%85%BE/rss/:3:1","tags":["RSS","信息"],"title":"RSS信息源","uri":"/posts/%E6%8A%98%E8%85%BE/rss/"},{"categories":["折腾"],"content":"PolitePol 免费的额度还可以，收费的更新速度更快，另外的功能我用到的比较少，暂时不会选择订阅。 ","date":"2023-11-27","objectID":"/posts/%E6%8A%98%E8%85%BE/rss/:3:2","tags":["RSS","信息"],"title":"RSS信息源","uri":"/posts/%E6%8A%98%E8%85%BE/rss/"},{"categories":["折腾"],"content":"FetchRSS 很贵，但是没看到竞争力体现在哪里 ","date":"2023-11-27","objectID":"/posts/%E6%8A%98%E8%85%BE/rss/:3:3","tags":["RSS","信息"],"title":"RSS信息源","uri":"/posts/%E6%8A%98%E8%85%BE/rss/"},{"categories":["折腾"],"content":"微信转RSS ","date":"2023-11-27","objectID":"/posts/%E6%8A%98%E8%85%BE/rss/:4:0","tags":["RSS","信息"],"title":"RSS信息源","uri":"/posts/%E6%8A%98%E8%85%BE/rss/"},{"categories":["折腾"],"content":"WeRSS 付费订阅，但是现在存在一些问题，作者修复的也比较消极，后续不打算继续使用。 ","date":"2023-11-27","objectID":"/posts/%E6%8A%98%E8%85%BE/rss/:4:1","tags":["RSS","信息"],"title":"RSS信息源","uri":"/posts/%E6%8A%98%E8%85%BE/rss/"},{"categories":["折腾"],"content":"P神星球 P神在星球提供了订阅微信公众号的方式，效果比较好，比较实时。缺点的话，是只能抓去标题，不过已经够用了。 ","date":"2023-11-27","objectID":"/posts/%E6%8A%98%E8%85%BE/rss/:4:2","tags":["RSS","信息"],"title":"RSS信息源","uri":"/posts/%E6%8A%98%E8%85%BE/rss/"},{"categories":["折腾"],"content":"补充 ","date":"2023-11-27","objectID":"/posts/%E6%8A%98%E8%85%BE/rss/:5:0","tags":["RSS","信息"],"title":"RSS信息源","uri":"/posts/%E6%8A%98%E8%85%BE/rss/"},{"categories":["折腾"],"content":"Qi Reader 国内不错的RSS阅读器，跟inoreader基础的功能差不多，但是便宜很多。 尽管如此，我还是更喜欢用inoreader，qireader似乎不支持存储拉取的文章（不确定），但是界面啥的个人感觉要优于inoreader。 ","date":"2023-11-27","objectID":"/posts/%E6%8A%98%E8%85%BE/rss/:5:1","tags":["RSS","信息"],"title":"RSS信息源","uri":"/posts/%E6%8A%98%E8%85%BE/rss/"},{"categories":["折腾"],"content":"feedly 很贵，而且界面也不是我喜欢的类型，看上去乱糟糟的。优势在于集成了AI可以生成文章的摘要。 ","date":"2023-11-27","objectID":"/posts/%E6%8A%98%E8%85%BE/rss/:5:2","tags":["RSS","信息"],"title":"RSS信息源","uri":"/posts/%E6%8A%98%E8%85%BE/rss/"},{"categories":["折腾"],"content":"最新的方案 1、inoreader pro（土区订阅2000里拉，约500元/年） 2、无RSS源转RSS inoreader自带20个 RSSEverything (主) PolitePol（辅:可以点击选择） 3、公众号转RSS wechat2rss（主） Wechat2RSS:架构演进 | 明天的乌云 WeRSS（辅）–\u003e 使用今天看啥（主），还挺不错的 摸鱼百分百-tel群（辅） P神的星球Sec-News（辅） 4、其他转RSS RSSHUB twitter转RSS（rsshub牛逼，inoreader当前不支持twitter，得亏rsshub） 5、自建RSS服务 rsscatcheryp (自建的rsshub，感觉官方的够用了) ","date":"2023-11-27","objectID":"/posts/%E6%8A%98%E8%85%BE/rss/:6:0","tags":["RSS","信息"],"title":"RSS信息源","uri":"/posts/%E6%8A%98%E8%85%BE/rss/"},{"categories":["折腾"],"content":"自建公众号转RSS 1、RSSHUB部分支持 2、我所使用过的微信公众号文章转 RSS 的方法 · ZMonster’s Blog 3、为一个基于 efb v2 的公众号抓取输出方案提供支持 · Issue #2172 · DIYgod/RSSHub 4、Hamibot 安卓自动化脚本工具 使用EFB的方式需要可以登录web版的微信，而且一旦使用之后没法再登录PC端和iPad端的微信。 ","date":"2023-11-27","objectID":"/posts/%E6%8A%98%E8%85%BE/rss/:6:1","tags":["RSS","信息"],"title":"RSS信息源","uri":"/posts/%E6%8A%98%E8%85%BE/rss/"},{"categories":["折腾"],"content":"参考 Feed43倒了，还有好用的网页生成RSS服务吗？ ","date":"2023-11-27","objectID":"/posts/%E6%8A%98%E8%85%BE/rss/:7:0","tags":["RSS","信息"],"title":"RSS信息源","uri":"/posts/%E6%8A%98%E8%85%BE/rss/"},{"categories":["折腾"],"content":"在折腾blog中，使用github actions遇到的问题和解决方案。 ","date":"2023-11-15","objectID":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/:0:0","tags":["blog"],"title":"Github Actions研究","uri":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/"},{"categories":["折腾"],"content":"问题 ","date":"2023-11-15","objectID":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/:1:0","tags":["blog"],"title":"Github Actions研究","uri":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/"},{"categories":["折腾"],"content":"问题描述 我想根据下面这两个链接： 让blog能够自动从sec-yp-blog仓库部署到catcheryp.github.io仓库 在自动发布的时候保证上传blog生成的index.json文件到Algolia中，以便于在blog上集成Algolia的搜索功能 参考链接： Hugo + GitHub Action，搭建你的博客自动发布系统 · Pseudoyu # 如果有报错的话，需要删除public文件夹 rm -rf public git rm --cached public 使用 GitHub Actions 自动上传搜索记录到 Algolia · 回忆中的明天 博客名自动发布的github action为： name: deploy on: push: workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \"0 0 * * *\" jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \"latest\" - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: Catcheryp/Catcheryp.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 上传Algolia的github action为： name: Algolia Upload Records on: [push] #推送时执行 jobs: algolia: runs-on: ubuntu-latest steps: - name: Checkout # 获取代码 Checkout uses: actions/checkout@v2 - name: Upload Records # 使用 Action uses: iChochy/Algolia-Upload-Records@1.1 # 设置环境变量 env: APPLICATION_ID: ${{secrets.APPLICATION_ID}} ADMIN_API_KEY: ${{secrets.ADMIN_API_KEY}} INDEX_NAME: blog FILE_PATH: index.json 其实只要将两个action合并即可，很简单的一个问题，但是由于变量设置错误，让我搞了很长时间。 ","date":"2023-11-15","objectID":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/:1:1","tags":["blog"],"title":"Github Actions研究","uri":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/"},{"categories":["折腾"],"content":"问题原因 ","date":"2023-11-15","objectID":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/:1:2","tags":["blog"],"title":"Github Actions研究","uri":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/"},{"categories":["折腾"],"content":"Github Actions常用 ","date":"2023-11-15","objectID":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/:2:0","tags":["blog"],"title":"Github Actions研究","uri":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/"},{"categories":["折腾"],"content":"actions/checkout@v2 actions/checkout@v2：意思是在docker容器中拉取当前仓库内容。 ","date":"2023-11-15","objectID":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/:2:1","tags":["blog"],"title":"Github Actions研究","uri":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/"},{"categories":["折腾"],"content":"needs 下面使用了needs，表示algolia操作会在build之后 name: deploy on: push: jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \"latest\" - name: Build Web run: hugo algolia: needs: build runs-on: ubuntu-latest steps: - name: List files in public directory run: ls public/index.json ","date":"2023-11-15","objectID":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/:2:2","tags":["blog"],"title":"Github Actions研究","uri":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/"},{"categories":["折腾"],"content":"在工作流作业间传递数据 name: deploy on: push: jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \"latest\" - name: Build Web run: hugo - name: Upload json uses: actions/upload-artifact@v3 with: name: homework path: index.json job_2: name: read json needs: build runs-on: ubuntu-latest steps: - name: Download result for build uses: actions/download-artifact@v3 with: name: homework - name: Read run: | cat index.json 这里很奇怪，第一次运行的时候没有任何问题，后面就一直运行失败。 参考： 将工作流程数据存储为构件 - GitHub 文档 ","date":"2023-11-15","objectID":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/:2:3","tags":["blog"],"title":"Github Actions研究","uri":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/"},{"categories":["折腾"],"content":"两种解决方案 方案一：目前使用的 name: deploy on: push: workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \"0 0 * * *\" jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \"latest\" - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: Catcheryp/Catcheryp.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} - name: Upload Records # 使用 Action uses: iChochy/Algolia-Upload-Records@1.1 # 设置环境变量 env: APPLICATION_ID: ${{secrets.APPLICATION_ID}} ADMIN_API_KEY: ${{secrets.ADMIN_API_KEY}} INDEX_NAME: blog FILE_PATH: ./public/index.json 方案二： name: deploy on: push: workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \"0 0 * * *\" jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \"latest\" - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: Catcheryp/Catcheryp.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} - name: upload uses: wangchucheng/algolia-uploader@master with: # Such as `Z0U0ACGBN8` app_id: ${{ secrets.APPLICATION_ID }} # You can store token in your project's 'Setting \u003e Secrets' and reference the name here. Such as ${{ secrets.ALGOLIA_ADMIN_KEY }} admin_key: ${{ secrets.ADMIN_API_KEY }} # The index name. index_name: blog # The index file path relative to repo root. index_file_path: public/index.json ","date":"2023-11-15","objectID":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/:3:0","tags":["blog"],"title":"Github Actions研究","uri":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/"},{"categories":["折腾"],"content":"参考 玩转 GitHub Actions | HeyFE 将工作流程数据存储为构件 - GitHub 文档 GitHub Actions 入门教程 - 阮一峰的网络日志 ","date":"2023-11-15","objectID":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/:4:0","tags":["blog"],"title":"Github Actions研究","uri":"/posts/%E6%8A%98%E8%85%BE/github-actions%E7%A0%94%E7%A9%B6/"},{"categories":["Tips"],"content":"一些经常会用到的Tips总结。 ","date":"2023-11-09","objectID":"/posts/tips/:0:0","tags":["snipaste","git","typora"],"title":"Tips","uri":"/posts/tips/"},{"categories":["Tips"],"content":"快速截图 ","date":"2023-11-09","objectID":"/posts/tips/:1:0","tags":["snipaste","git","typora"],"title":"Tips","uri":"/posts/tips/"},{"categories":["Tips"],"content":"Snipaste Ctrl + F1 – 截图后直接复制 R – 使用上一次截图区域 Ctrl+F1 --\u003e R --\u003e Alt+Tab --\u003e Ctrl+V – 快速截图复制 ","date":"2023-11-09","objectID":"/posts/tips/:1:1","tags":["snipaste","git","typora"],"title":"Tips","uri":"/posts/tips/"},{"categories":["Tips"],"content":"定时截图 可以自动定时截图 https://www.faststone.org/FSCaptureDetail.htm ","date":"2023-11-09","objectID":"/posts/tips/:1:2","tags":["snipaste","git","typora"],"title":"Tips","uri":"/posts/tips/"},{"categories":["Tips"],"content":"typora ","date":"2023-11-09","objectID":"/posts/tips/:2:0","tags":["snipaste","git","typora"],"title":"Tips","uri":"/posts/tips/"},{"categories":["Tips"],"content":"自动编号 在theme主题的根目录下添加base.user.css文件，并在其中添加如下内容： /** initialize css counter */ #write { counter-reset: h2 } h2 { counter-reset: h3 } h3 { counter-reset: h4 } h4 { counter-reset: h5 } h5 { counter-reset: h6 } /** put counter result into headings */ #write h2:before { counter-increment: h2; content: counter(h2) \". \" } #write h3:before, h3.md-focus.md-heading:before /** override the default style for focused headings */ { counter-increment: h3; content: counter(h2) \".\" counter(h3) \" \" } #write h4:before, h4.md-focus.md-heading:before { counter-increment: h4; content: counter(h2) \".\" counter(h3) \".\" counter(h4) \" \" } #write h5:before, h5.md-focus.md-heading:before { counter-increment: h5; content: counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \" \" } #write h6:before, h6.md-focus.md-heading:before { counter-increment: h6; content: counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \".\" counter(h6) \" \" } /** override the default style for focused headings */ #write\u003eh3.md-focus:before, #write\u003eh4.md-focus:before, #write\u003eh5.md-focus:before, #write\u003eh6.md-focus:before, h3.md-focus:before, h4.md-focus:before, h5.md-focus:before, h6.md-focus:before { color: inherit; border: inherit; border-radius: inherit; position: inherit; left:initial; float: none; top:initial; font-size: inherit; padding-left: inherit; padding-right: inherit; vertical-align: inherit; font-weight: inherit; line-height: inherit; } /* toc 自动编号 */ .sidebar-content { counter-reset: h2 } .outline-h2 { counter-reset: h3 } .outline-h3 { counter-reset: h4 } .outline-h4 { counter-reset: h5 } .outline-h5 { counter-reset: h6 } .outline-h2\u003e.outline-item\u003e.outline-label:before { counter-increment: h2; content: counter(h2) \". \" } .outline-h3\u003e.outline-item\u003e.outline-label:before { counter-increment: h3; content: counter(h2) \".\" counter(h3) \" \" } .outline-h4\u003e.outline-item\u003e.outline-label:before { counter-increment: h4; content: counter(h2) \".\" counter(h3) \".\" counter(h4) \" \" } .outline-h5\u003e.outline-item\u003e.outline-label:before { counter-increment: h5; content: counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \" \" } .outline-h6\u003e.outline-item\u003e.outline-label:before { counter-increment: h6; content: counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \".\" counter(h6) \" \" } ","date":"2023-11-09","objectID":"/posts/tips/:2:1","tags":["snipaste","git","typora"],"title":"Tips","uri":"/posts/tips/"},{"categories":["Tips"],"content":"h1居中 直接在主题文件中添加如下代码，我的是在vue.css中添加： h1{ text-align: center; } ","date":"2023-11-09","objectID":"/posts/tips/:2:2","tags":["snipaste","git","typora"],"title":"Tips","uri":"/posts/tips/"},{"categories":["Tips"],"content":"图片添加圆角和边框 1、在base-control.css文件中修改 2、查询img{cursor，在后面添加如下代码： border: 1px solid #c7cac8; border-radius: 10px; ","date":"2023-11-09","objectID":"/posts/tips/:2:3","tags":["snipaste","git","typora"],"title":"Tips","uri":"/posts/tips/"},{"categories":["Tips"],"content":"参考 https://support.typora.io/Auto-Numbering/ – 文章标题自动编号 https://pastebin.com/XmYgBbaz – toc自动编号 Typora 自定义格式：引用、行内代码块、图象加边框 ","date":"2023-11-09","objectID":"/posts/tips/:2:4","tags":["snipaste","git","typora"],"title":"Tips","uri":"/posts/tips/"},{"categories":["Tips"],"content":"其他 ","date":"2023-11-09","objectID":"/posts/tips/:3:0","tags":["snipaste","git","typora"],"title":"Tips","uri":"/posts/tips/"},{"categories":["Tips"],"content":"直角引号 自己的电脑上输入yp，会出现直角引号，因为之前我有设置过。 ","date":"2023-11-09","objectID":"/posts/tips/:3:1","tags":["snipaste","git","typora"],"title":"Tips","uri":"/posts/tips/"},{"categories":["折腾"],"content":"为什么我要重新来写blog，还是要坚持分享。 ","date":"2023-11-09","objectID":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/:0:0","tags":["blog"],"title":"重拾Blog","uri":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/"},{"categories":["折腾"],"content":"hugo常用 ../hugo.exe server $ cat ~/.bashrc alias ub=\"git add . \u0026\u0026 git commit -m 'update blog' \u0026\u0026 git push\" # 每次在git bash里面执行ub即可 ","date":"2023-11-09","objectID":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/:1:0","tags":["blog"],"title":"重拾Blog","uri":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/"},{"categories":["折腾"],"content":"主题定制化 ","date":"2023-11-09","objectID":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/:2:0","tags":["blog"],"title":"重拾Blog","uri":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/"},{"categories":["折腾"],"content":"标题自动编号 在_single.scss中给标题自动编号（参考typora） /** initialize css counter */ #content { counter-reset: h2 } h2 { counter-reset: h3 } h3 { counter-reset: h4 } h4 { counter-reset: h5 } h5 { counter-reset: h6 } /** put counter result into headings */ #content h2:before { counter-increment: h2; content: counter(h2) \". \" } #content h3:before, h3.header-mark:before /** override the default style for focused headings */ { counter-increment: h3; content: counter(h2) \".\" counter(h3) \" \" } #content h4:before, h4.header-mark:before { counter-increment: h4; content: counter(h2) \".\" counter(h3) \".\" counter(h4) \" \" } #content h5:before, h5.header-mark:before { counter-increment: h5; content: counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \" \" } #content h6:before, h6.header-mark:before { counter-increment: h6; content: counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \".\" counter(h6) \" \" } /** override the default style for focused headings */ #content\u003eh3.header-mark:before, #content\u003eh4.header-mark:before, #content\u003eh5.header-mark:before, #content\u003eh6.header-mark:before, h3.header-mark:before, h4.header-mark:before, h5.header-mark:before, h6.header-mark:before { color: inherit; border: inherit; border-radius: inherit; position: inherit; left:initial; float: none; top:initial; font-size: inherit; padding-left: inherit; padding-right: inherit; vertical-align: inherit; font-weight: inherit; line-height: inherit; } ","date":"2023-11-09","objectID":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/:2:1","tags":["blog"],"title":"重拾Blog","uri":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/"},{"categories":["折腾"],"content":"目录自动编号 修改_toc.scss 因为blog的toc并没有给不同级别的标题添加不同的class，所以没法参考typora的方式来自动编号。 暂时我也没想到好的方案。 ","date":"2023-11-09","objectID":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/:2:2","tags":["blog"],"title":"重拾Blog","uri":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/"},{"categories":["折腾"],"content":"hexo icarus（2020-8-15） ","date":"2023-11-09","objectID":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/:3:0","tags":["blog"],"title":"重拾Blog","uri":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/"},{"categories":["折腾"],"content":"博客主题 icarus hexo-theme-amazing ","date":"2023-11-09","objectID":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/:3:1","tags":["blog"],"title":"重拾Blog","uri":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/"},{"categories":["折腾"],"content":"炫酷的页面元素 Bulma文档 ","date":"2023-11-09","objectID":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/:3:2","tags":["blog"],"title":"重拾Blog","uri":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/"},{"categories":["折腾"],"content":"图片 1.图床使用的是七牛云 2.Mac有个很好用的上传图片的工具iPic ","date":"2023-11-09","objectID":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/:3:3","tags":["blog"],"title":"重拾Blog","uri":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/"},{"categories":["折腾"],"content":"SSL 又拍云的免费SSL ","date":"2023-11-09","objectID":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/:3:4","tags":["blog"],"title":"重拾Blog","uri":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/"},{"categories":["折腾"],"content":"CDN 又拍云的免费CDN ","date":"2023-11-09","objectID":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/:3:5","tags":["blog"],"title":"重拾Blog","uri":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/"},{"categories":["折腾"],"content":"博客自定义 https://www.alphalxy.com/2019/03/customize-icarus/ 自定义diff ","date":"2023-11-09","objectID":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/:3:6","tags":["blog"],"title":"重拾Blog","uri":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/"},{"categories":["折腾"],"content":"参考 Icarus 常见问题 活用 Bulma 美化 Icarus 文章 ","date":"2023-11-09","objectID":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/:3:7","tags":["blog"],"title":"重拾Blog","uri":"/posts/%E6%8A%98%E8%85%BE/%E9%87%8D%E6%8B%BEblog/"},{"categories":["Python"],"content":"python tricks，持续更新…… ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:0:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"启动服务器 # python2 python -m SimpleHTTPServer 8001 # python3 python3 -m http.server 3000 ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:1:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"*args和**kwargs ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:2:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"介绍 *args是可变的positional arguments列表 **kwargs是可变的keyword arguments列表 *args必须位于**kwargs之前 如果说在函数定义的位置使用*args和**kwargs是一个将参数pack的过程，那么在函数调用的时候就是一个将参数unpack的过程了 ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:2:1","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"参考 https://kodango.com/variable-arguments-in-python ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:2:2","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"一行式 class A(object): def __init__(self, a, b, c, d, e, f): self.__dict__.update({k: v for k, v in locals().items() if k != 'self'}) 参考 https://eastlakeside.gitbook.io/interpy-zh/onelines ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:3:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"Python的itertools模板 参考： http://wklken.me/posts/2013/08/20/python-extra-itertools.html https://blog.csdn.net/fuxuemingzhu/article/details/79869193 可以先看下 itertools.combinations(points, 3) itertools.permutations()全排列 itertools.combinations()组合 经典题目： https://leetcode-cn.com/problems/ambiguous-coordinates/description/ ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:4:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"Python中定义二维数组 ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:5:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"引入 昨天做算法题目的时候遇到一个贼坑的Python语法问题，就跟我以前开始不知道Python里面的字符串不可更改一样。 下面直接来看一个例子吧： #coding: utf-8 a = [[]]*5 a[0].append(1) print a 对于上面这个例子，我心里的预期结果是： [[1], [], [], [], []] 但是很遗憾我得到的结果却是： [[1], [1], [1], [1], [1]] 为什么会这样呢？究其原因是因为Python的语法特性，直接来看官方文档的解释 What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. 所以创建二维数组时，应该按照以下方法创建： \u003e\u003e\u003e lists = [[] for i in range(3)] \u003e\u003e\u003e lists[0].append(3) \u003e\u003e\u003e lists[1].append(5) \u003e\u003e\u003e lists[2].append(7) \u003e\u003e\u003e lists [[3], [5], [7]] 参考： https://www.cnblogs.com/woshare/p/5823303.html ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:5:1","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"延伸 新手常犯的错误：直接google新手常犯的错误 ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:5:2","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"字典(dict) ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:6:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"基础使用 Python 中的动态数组是如何使用的 获取字典的键值和values dict.get(key, default=None) 返回指定键的值，如果值不在字典中返回default值 参考：菜鸟教程 ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:6:1","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"按key值或按value值排序 下面是按key对字典进行排序 d = sorted(data.items(), key=lambda item:item[0], reverse=True) ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:6:2","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"一个有趣的python排序模块：bisect 参考：https://www.cnblogs.com/skydesign/archive/2011/09/02/2163592.html ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:7:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"python 中swap a, b = b, a b, a = a, b 在涉及到数组的时候会有点不一样，有时候出错很可能会在这里出错，最保险的是用3行进行交换 ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:8:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"Python模块包 可以将功能相似的模块放在同一个文件夹（比如说this_dir）中，构成一个模块包。 通过 import this_dir.module 引入this_dir文件夹中的module模块。 该文件夹中必须包含一个__init__.py的文件，提醒Python，该文件夹为一个模块包。__init__.py可以是一个空文件。 ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:9:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"Python排序 Python对二维数组进行排序 a = [[2,3],[1,2],[5,2],[4,1]] # 按照第二列进行排序 b = sorted(a, key=lambda a:a[1]) a = [[3, 4], [5, 6], [6, 5], [7, 2], [7, 0], [7, 1]] #如果第一个元素相同那么按照第二个元素排序 c = sorted(a, key=lambda a:(a[0],a[1])) # 添加负号表示逆序 c = sorted(a, key=lambda a:(-a[0],a[1])) 参考： https://blog.csdn.net/hanshileiai/article/details/44241385 题目:406. 根据身高重建队列 ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:10:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"yield用法 ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:11:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"简介 next() send() yield from 的用法 参考： http://youchen.me/2017/02/10/Python-main-use-for-yield-from/ http://blog.gusibi.com/post/python-coroutine-yield-from/ 参考： https://www.jianshu.com/p/d676543ccdbb https://zhuanlan.zhihu.com/p/23276711 http://pyzh.readthedocs.io/en/latest/the-python-yield-keyword-explained.html ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:11:1","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"python zip() 关于zip的使用 class Solution(object): def carFleet(self, target, position, speed): cars = sorted(zip(position, speed)) times = [float(target - p) / s for p, s in cars] ans = 0 while len(times) \u003e 1: lead = times.pop() if lead \u003c times[-1]: ans += 1 # if lead arrives sooner, it can't be caught else: times[-1] = lead # else, fleet arrives at later time 'lead' return ans + bool(times) # remaining car is fleet (if it exists) 例子： https://leetcode.com/problems/car-fleet/solution/ ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:12:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"牛逼哄哄的注释 # Python大法好 入教保平安 # _ooOoo_ # o8888888o # 88\" . \"88 # (| °_° |) # O\\ = /O # ____/`---'\\____ # .' \\\\| |// `. # / \\\\||| : |||// \\ # / _||||| -:- |||||- \\ # | | \\\\\\ - /// | | # | \\_| ''\\---/'' | | # \\ .-\\__ `-` ___/-. / # ___`. .' /--.--\\ `. . __ # .\"\" '\u003c `.___\\_\u003c|\u003e_/___.' \u003e'\"\". # | | : `- `.;`\\ _ /`;.`/ - ` : | | # \\ \\ `-. \\_ __\\ /__ _/ .-` / / # ======`-.____`-.___\\_____/___.-`____.-'====== # `=---=' # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ # 佛祖保佑 永无BUG # 练手项目 锻炼技巧 不要做坏事 出事与本人无关 ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:13:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"列出当前目录下所有文件和目录名 import os #导入os模块，模块的概念后面讲到 [d for d in os.listdir('.')] # os.listdir可以列出文件和目录 ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:14:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"简易进度条 import sys sys.stdout.write(\"#:{0}\\r\".format(i)) sys.stdout.flush() \\r 回到一行的头部 example： #encoding: utf-8 import sys import time for i in range(30): time.sleep(0.5) sys.stdout.write(\"##:{0}/30\\r\".format(i)) sys.stdout.flush() 参考： http://python.jobbole.com/83692/ ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:15:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"collections import collections lst = [] # lst存放所谓的100万个元素 d = collections.Counter(lst) # 瞬间出结果 for k in d: # k是lst中的每个元素 # d[k]是k在lst中出现的次数 ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:16:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"hostname-\u003eIP #Resolve all hostnames in a file to IP addresses: import sys, socket f = open(sys.argv[1]) for i in f: i = i.rstrip() try: ip = socket.gethostbyname(i) except: ip = \"Doesn't resolve\" print(i + \" -\u003e \" + ip) ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:17:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"Py 文件转成 EXE 文件 参考:https://www.youtube.com/watch?v=UZX5kH72Yx4\u0026t=28s 这里我使用这个项目作为示例:https://github.com/yangshun/2048-python $pip3 install pyinstaller # 这一步会生成两个文件夹和一个文件，只保留 dir 里面的 exe 文件就可以了 $pyinstaller --onefile -w puzzle.py 下面将生成的 exe 文件移动到项目的主目录下，然后生成 zip 文件 使用 NSIS 生成最终的可以在 windows 上安装的 exe 文件就可以了 ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:18:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"单下划线和双下划线 ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:19:0","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"单下划线 单下划线前缀名称(例如_pythonPoint)： 这表示这是一个保护成员（属性或者方法），只有类对象和子类对象自己能访问到这些变量，是用来指定私有变量和方法的一种方式(约定而已)。 单下划线后缀名称： 通常用于和Python关键词区分开来 ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:19:1","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"双下划线 “双下划线” 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。 ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:19:2","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"ref https://zhuanlan.zhihu.com/p/36173202 https://juejin.im/post/6844903937976303624 ","date":"2021-02-08","objectID":"/posts/python/python-tricks/:19:3","tags":["tips"],"title":"Python Tricks","uri":"/posts/python/python-tricks/"},{"categories":["Python"],"content":"python虚拟环境常用总结。 ","date":"2021-02-08","objectID":"/posts/python/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:0","tags":["pipenv"],"title":"Python虚拟环境","uri":"/posts/python/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"pipenv pip install pipenv #用户安装，避免破坏全局的包 pip install --user pipenv pipenv install #指定虚拟环境中的python版本 --three --two #激活虚拟环境 pipenv shell #不显式激活虚拟环境，即可在当前项目的虚拟环境中执行命令 pipenv run python hello.py Pipfile: 记录项目依赖包列表 Pipfile.lock: 记录了固定版本的详细依赖包列表 #更新 pipenv update flask ","date":"2021-02-08","objectID":"/posts/python/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:1:0","tags":["pipenv"],"title":"Python虚拟环境","uri":"/posts/python/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"virtualenv virtualenv -p python3 envname envname 是项目名称，可改 我觉得你真的应该学一下virtualenv的命令 virtualenv -p python3 Django #进入虚拟环境 cd Django #激活虚拟环境 source ./bin/activate #退出虚拟环境 deactivate #删除虚拟环境 rm -rf Django #带上这个参数，就不会复制任何第三方的包过来 --no-site-packages ","date":"2021-02-08","objectID":"/posts/python/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:0","tags":["pipenv"],"title":"Python虚拟环境","uri":"/posts/python/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"参考 http://stackoverflow.com/questions/23842713/using-python-3-in-virtualenv https://www.liaoxuefeng.com/wiki/1016959663602400/10192731431204804 ","date":"2021-02-08","objectID":"/posts/python/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:1","tags":["pipenv"],"title":"Python虚拟环境","uri":"/posts/python/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"要安装paramiko库，但是公司机器无法连外网，公司yum源在这台机器上也没法使用，即使能使用pip源也用不了。 最近在搭建一个简易的平台，使用python cgi实现后台的简单逻辑需要安装paramiko库，但是很尴尬的是公司管理面的机器无法连外网，公司yum源的地址在这台机器上也没法使用，即使能使用pip源也用不了，就是各种坑。 ","date":"2020-01-20","objectID":"/posts/python/python%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%BA%93/:0:0","tags":["tips"],"title":"离线安装Python各种库","uri":"/posts/python/python%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%BA%93/"},{"categories":["Python"],"content":"离线安装的几种思路 1.修改yum源，使用公司内部的yum源，且保证有pip源 2.使用跳板机，利用跳板机来连外网，在本地开个代理即可 3.下载python库但是不安装，然后再移植到目标机器上，具体操作步骤参考这里 4.在Linux上生成python虚拟化环境，并下载好所需要的包，直接移植到目标机器上 ","date":"2020-01-20","objectID":"/posts/python/python%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%BA%93/:1:0","tags":["tips"],"title":"离线安装Python各种库","uri":"/posts/python/python%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%BA%93/"},{"categories":["Python"],"content":"背景 对于第一种方法，直接pass掉 对于第二种方法，在公司内使用export http://xxxxxx走的还必须是公司的代理，需要填我的账号和密码，本身只是鉴权的作用，需要这台机器本身就能连通目标网址。但是目标机器连不通目标网址，这种方法不行。 对于第三种方法，我在安装paramiko的时候，会下载另外的依赖库，这几个依赖库是系统相关的，而目标机器的系统是欧拉，我直接安装paramiko-2.7.1-py2.py3-none-any.whl 文件会报错No platform，意思是找不到对应的操作系统。此时如果坚持使用这种方法的，只有去自己装个欧拉的系统，且可以下载python库，然后按照这种方法移植过来，理论上来说是可以的。 对于第四种方法，我就是用这种方法的，下面主要介绍这种方法 ","date":"2020-01-20","objectID":"/posts/python/python%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%BA%93/:2:0","tags":["tips"],"title":"离线安装Python各种库","uri":"/posts/python/python%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%BA%93/"},{"categories":["Python"],"content":"python虚拟环境跨平台 1.目标机器的系统是欧拉，我现在centOS上生成python的虚拟环境，并下载好我需要的python库。 2.将python虚拟环境整个打包上传到目标机器上，在目标机器上解压缩。 3.此时你若source ./bin/activate 激活虚拟环境，你会发现在虚拟环境下并没有成功使用python虚拟环境，此时需要修改activate 文件里面的VIRTUAL_ENV=\"xxxx\"，将其修改成当前虚拟环境对应的路径。 4.修改完了之后，确实可以进入到python虚拟环境了，但是此时我import paramiko又报错了，显示我no socket module，这是因为python虚拟环境会从当前机器的python库里面拷贝内置的一些库，比如python自带的socket库，而sys.path里面的默认的路径是centOS中系统python的路径，此时就需要修改sys.path里面的内容，将centOS的路径改成本机自带的Python路径就可以了。 import sys sys.append(\"/usr/local/lib/python3.5\") import paramiko 按照以上修改之后就可以不报错了，这只是临时的解决方案，每次写代码都需要加上面这段才可以。还有一种永久的解决办法，修改venv/lib/python3.5/site.py，在里面加上一行sys.append(\"/usr/local/lib/python3.5\")，就可以永久生效了。 5.此时还没有完全解决我的问题，我希望前台触发的python直接就是虚拟环境的python，还需要将cgi脚本的shebang路径改成虚拟环境的路径/usr/bin/venv/bin/python3，同时在/etc/profile里面添加一行source /usr/bin/venv/bin/activate，然后source /etc/profile刷新一下即可。 ","date":"2020-01-20","objectID":"/posts/python/python%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%BA%93/:3:0","tags":["tips"],"title":"离线安装Python各种库","uri":"/posts/python/python%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%BA%93/"},{"categories":["Python"],"content":"更新 # 将安装包下载到本地 pip download paramiko # 将安装包上传到目标机器上，然后执行本地化安装即可 pip install --no-index --find-links=./ paramiko 不需要上面那么多步骤了 ","date":"2020-01-20","objectID":"/posts/python/python%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%BA%93/:4:0","tags":["tips"],"title":"离线安装Python各种库","uri":"/posts/python/python%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%BA%93/"},{"categories":["Linux"],"content":"2020年第一篇正儿八经的博客，好好学习下Linux，用C语言实现Linux下的ls命令，很基础的知识。 ","date":"2020-01-04","objectID":"/posts/linux/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0ls/:0:0","tags":["apue"],"title":"C语言实现Linux的ls命令","uri":"/posts/linux/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0ls/"},{"categories":["Linux"],"content":"基础知识 先看下DIR结构体、dirent结构体和stat结构体 struct __dirstream { void *__fd; char *__data; int __entry_data; char *__ptr; int __entry_ptr; size_t __allocation; size_t __size; __libc_lock_define (, __lock) }; typedef struct __dirstream DIR; struct dirent { ino_t d_ino; /* inode number 索引节点号*/ off_t d_off; /* offset to the next dirent 在目录文件中的偏移 */ unsigned short d_reclen; /* length of this record 文件名长*/ unsigned char d_type; /* type of file; not supported by all file system types 文件类型 */ char d_name[256]; /* filename 文件名*/ }; struct stat { mode_t st_mode; //文件访问权限 ino_t st_ino; //索引节点号 dev_t st_dev; //文件使用的设备号 dev_t st_rdev; //设备文件的设备号 nlink_t st_nlink; //文件的硬连接数 uid_t st_uid; //所有者用户识别号 gid_t st_gid; //组识别号 off_t st_size; //以字节为单位的文件容量 time_t st_atime; //最后一次访问该文件的时间 time_t st_mtime; //最后一次修改该文件的时间 time_t st_ctime; //最后一次改变该文件状态的时间 blksize_t st_blksize; //包含该文件的磁盘块的大小 blkcnt_t st_blocks; //该文件所占的磁盘块 }; 目录操作相关函数 //功能:打开一个目录; 返回值:成功则返回DIR*型态的目录流, 打开失败则返回NULL. DIR* opendir(constchar * path); //功能:循环读取dp中的文件和目录，每读取一个文件或目录都返回一个dirent结构体指针; 返回值:读取失败返回NULL struct dirent* readdir(DIR* dp); //功能:关闭参数dp所指的目录流; 返回值:关闭成功则返回0,，失败返回-1 int closedir(DIR*dp); //功能:通过文件名file_name获取文件信息，并保存在buf所指的结构体stat中; 返回值:执行成功则返回0，失败返回-1 int stat(const char *file_name,struct stat *buf); ","date":"2020-01-04","objectID":"/posts/linux/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0ls/:1:0","tags":["apue"],"title":"C语言实现Linux的ls命令","uri":"/posts/linux/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0ls/"},{"categories":["Linux"],"content":"ls的C语言实现 先实现个最简单的V1.0版本 #include\u003cstdio.h\u003e #include\u003csys/types.h\u003e #include\u003cdirent.h\u003e int main(int argc, char *argv[]){ DIR *dp; struct dirent *dirp; if(argc != 2){ printf(\"usage: ls directory_name\\n\"); } if((dp = opendir(argv[1])) == NULL){ printf(\"can't open %s\\n\", argv[1]); } while((dirp = readdir(dp)) != NULL){ printf(\"%s\\n\", dirp-\u003ed_name); } closedir(dp); exit(0); } 封装一下 #include\u003cstdio.h\u003e #include\u003csys/types.h\u003e #include\u003cdirent.h\u003e void do_ls(char[]); int main(int argc, char *argv[]) { if(argc==1) do_ls(\".\"); do_ls(argv[1]); return 0; } void do_ls(char dirname[]) { DIR *dp; struct dirent *dirp; if((dp=opendir(dirname))==NULL) fprintf(stderr,\"can't open %s\\n\",dirname); else { while((dirp=readdir(dp))!=NULL) printf(\"%s\\n\",dirp-\u003ed_name); closedir(dp); } } 再实现个V2.0版本使用stat结构体可以列出每个文件详细信息 #include\u003cstdio.h\u003e #include\u003csys/types.h\u003e #include\u003cdirent.h\u003e #include\u003csys/stat.h\u003e //代码的报错处理没写好 //列出文件的信息 void show_stat_info(char *, struct stat *); int main(int argc, char *argv[]){ struct stat info; if(argc != 2){ printf(\"usage: ls directory_name\\n\"); } //do_ls(*argv[1]); if(stat(argv[1], \u0026info) != -1){ show_stat_info(argv[1],\u0026info); } exit(0); } void show_stat_info(char *fname, struct stat *buf) { printf(\" mode: %o\\n\", buf-\u003est_mode); printf(\" links: %d\\n\", buf-\u003est_nlink); printf(\" user: %d\\n\", buf-\u003est_uid); printf(\" group: %d\\n\", buf-\u003est_gid); printf(\" size: %d\\n\", buf-\u003est_size); printf(\"modtime: %d\\n\", buf-\u003est_mtime); printf(\" group: %s\\n\", fname); } ------------------ $./test2 test mode: 100755 links: 1 user: 501 group: 20 size: 12772 modtime: 1578118793 group: test 实现个V3.0版本 #include\u003cstdio.h\u003e #include\u003csys/types.h\u003e #include\u003cdirent.h\u003e #include\u003csys/stat.h\u003e //代码的报错处理没写好 //列出目录下的所有文件 void do_ls(char[]); //展示文件信息 void dostat(char *); //列出文件的信息 void show_stat_info(char *, struct stat *); int main(int argc, char *argv[]){ if(argc==1) do_ls(\".\"); do_ls(argv[1]); return 0; } void do_ls(char dirname[]) { DIR *dp; struct dirent *dirp; if((dp=opendir(dirname))==NULL) fprintf(stderr,\"can't open %s\\n\",dirname); else { while((dirp=readdir(dp))!=NULL) //printf(\"%s\\n\",dirp-\u003ed_name); dostat(dirp-\u003ed_name); closedir(dp); } } void dostat(char *filename) { struct stat info; if(stat(filename,\u0026info)==-1) perror(filename); else show_stat_info(filename,\u0026info); } void show_stat_info(char *fname, struct stat *buf) { printf(\" mode: %o\\n\", buf-\u003est_mode); printf(\" links: %d\\n\", buf-\u003est_nlink); printf(\" user: %d\\n\", buf-\u003est_uid); printf(\" group: %d\\n\", buf-\u003est_gid); printf(\" size: %d\\n\", buf-\u003est_size); printf(\"modtime: %d\\n\", buf-\u003est_mtime); printf(\" group: %s\\n\", fname); } -------------------- $./test1 ./ mode: 40700 links: 63 user: 501 group: 20 size: 2016 modtime: 1578125448 group: . mode: 40755 links: 145 user: 501 group: 20 size: 4640 modtime: 1578125452 group: .. mode: 40755 links: 9 user: 501 group: 20 size: 288 modtime: 1575381270 group: rce-over-spark mode: 40755 links: 7 user: 501 group: 20 size: 224 现在可以写出最终版本了，把文件展示出来的信息修改成与ls一致的信息即可 这里需要补充两个结构体，是将user和group的数字形式转换成name形式 //pwd.h struct passwd { char *pw_name; /* Username. */ char *pw_passwd; /* Password. */ __uid_t pw_uid; /* User ID. */ __gid_t pw_gid; /* Group ID. */ char *pw_gecos; /* Real name. */ char *pw_dir; /* Home directory. */ char *pw_shell; /* Shell program. */ }; //grp.h struct group { char *gr_name; /* Group name. */ char *gr_passwd; /* Password. */ __gid_t gr_gid; /* Group ID. */ char **gr_mem; /* Member list. */ }; #include\u003cstdio.h\u003e #include\u003csys/types.h\u003e #include\u003cdirent.h\u003e #include\u003csys/stat.h\u003e #include \u003cgrp.h\u003e #include \u003cpwd.h\u003e //代码的报错处理没写好 //列出目录下的所有文件 void do_ls(char[]); //展示文件信息 void dostat(char *); //列出文件的信息 void show_file_info(char *, struct stat *); //将文件属性修改成d/-,权限修改成rwx void mode_to_letters(int ,char[]); char * uid_to_name(uid_t); char * gid_to_name(gid_t); int main(int argc, char *argv[]){ if(argc==1) do_ls(\".\"); do_ls(argv[1]); return 0; } void do_ls(char dirname[]) { DIR *dp; struct dirent *dirp; if((dp=opendir(dirname))==NULL) fprintf(stderr,\"can't open %s\\n\",dirname); else { while((dirp","date":"2020-01-04","objectID":"/posts/linux/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0ls/:2:0","tags":["apue"],"title":"C语言实现Linux的ls命令","uri":"/posts/linux/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0ls/"},{"categories":["Linux"],"content":"Ref https://blog.nowcoder.net/n/9a48a7f697864e3bbdae2fe5bfcb0ef9 https://melville.club/posts/a-20190123-095755 ","date":"2020-01-04","objectID":"/posts/linux/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0ls/:3:0","tags":["apue"],"title":"C语言实现Linux的ls命令","uri":"/posts/linux/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0ls/"},{"categories":["基础"],"content":"记录常用的 git 命令，持续更新…… ","date":"2018-08-11","objectID":"/posts/%E5%9F%BA%E7%A1%80/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/:0:0","tags":["git","基础","coding"],"title":"Git常用命令","uri":"/posts/%E5%9F%BA%E7%A1%80/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"categories":["基础"],"content":"修改之后提交 $ git clone https://github.com/Catcheryp/Catcheryp.github.io.git $ git add . $ git commit -m \"XXX\" $ git push ","date":"2018-08-11","objectID":"/posts/%E5%9F%BA%E7%A1%80/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/:1:0","tags":["git","基础","coding"],"title":"Git常用命令","uri":"/posts/%E5%9F%BA%E7%A1%80/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"categories":["基础"],"content":"提交本地文件 $ cd ~/Code/test $ git init $ git add -A $ git commit -m \"Initial commit\" //远程创建了名为 test 的 repo $ git init $ git remote add origin git@github.com:Catcheryp/test.git $ git push -u origin master //创建分支 $ git checkout master 将当前分支切换到 master 分支上 $ git checkout -b new-test 将会为你创建一个名为 new-test 的新分支 ---- $ git checkout master //切换到主分支 $ git merge new-test //合并分支 $ git branch -d new-test //删除分支 ---- $ git branch -l //查看本地分支 $ git branch -r //查看远程分支 $ git commit -m \"last\" XXX---\u003e中间经历若干操作 $ git add -A $ git checkout -f //放弃中间经历的若干操作，回到上次 commit 的地方 ","date":"2018-08-11","objectID":"/posts/%E5%9F%BA%E7%A1%80/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/:2:0","tags":["git","基础","coding"],"title":"Git常用命令","uri":"/posts/%E5%9F%BA%E7%A1%80/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"categories":["基础"],"content":"打标签发布 $ git tag v0.1-alpha //创建轻量标签 $ git push origin --tags //把所有不在远程仓库服务器上的标签全部传送到那里 $ git tag //在 Git 中列出已有的标签 ","date":"2018-08-11","objectID":"/posts/%E5%9F%BA%E7%A1%80/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/:3:0","tags":["git","基础","coding"],"title":"Git常用命令","uri":"/posts/%E5%9F%BA%E7%A1%80/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"categories":["基础"],"content":"常见问题 # 1、当本地和远程的内容不一致，push报错的时候，使用下面的命令可以让，远程的仓库覆盖本地的仓库(如下图) git fetch --all \u0026\u0026 git reset --hard origin/main \u0026\u0026 git pull # 2、更新blog alias ub=\"git add . \u0026\u0026 git commit -m 'update blog' \u0026\u0026 git push\" # 查看建立的软连接 alias # 3、git bash中建立永久软连接：新建~/.bashrc文件，并将上面的命令添加进去即可 vim ~/.bashrc source ~/.bashrc # 4、git强制提交本地分支覆盖远程分支 git push origin master --force ","date":"2018-08-11","objectID":"/posts/%E5%9F%BA%E7%A1%80/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/:4:0","tags":["git","基础","coding"],"title":"Git常用命令","uri":"/posts/%E5%9F%BA%E7%A1%80/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"categories":["基础"],"content":"参考： https://git-scm.com/book/zh/v2 ","date":"2018-08-11","objectID":"/posts/%E5%9F%BA%E7%A1%80/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/:5:0","tags":["git","基础","coding"],"title":"Git常用命令","uri":"/posts/%E5%9F%BA%E7%A1%80/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"categories":["折腾"],"content":"给博客添加小绿锁，将 http 转到 https。 ","date":"2018-05-29","objectID":"/posts/%E6%8A%98%E8%85%BE/%E5%8D%9A%E5%AE%A2%E5%8A%A0https/:0:0","tags":["https"],"title":"博客加小绿锁","uri":"/posts/%E6%8A%98%E8%85%BE/%E5%8D%9A%E5%AE%A2%E5%8A%A0https/"},{"categories":["折腾"],"content":"Tips 我是利用Netlify来给博客添加https的，具体的步骤我就不做赘述了，这里给出两个链接基本涵盖了可能遇到的问题。 利用Netlify为GitHub Pages with Custom Domain实现HTTPS访问 GitHub Page 博客自定义域名添加 HTTPS 支持 需要注意的是： 确保你的仓库里有Gemfile文件; 删除你仓库里面的CNAME文件; 在Netlify上操作完毕后大概需要等1小时左右才能看到博客加了https; ","date":"2018-05-29","objectID":"/posts/%E6%8A%98%E8%85%BE/%E5%8D%9A%E5%AE%A2%E5%8A%A0https/:1:0","tags":["https"],"title":"博客加小绿锁","uri":"/posts/%E6%8A%98%E8%85%BE/%E5%8D%9A%E5%AE%A2%E5%8A%A0https/"},{"categories":["折腾"],"content":"尴尬 之所以说尴尬是因为我在用完这种方式成功给博客加了小绿锁之后，又发现从5月1号开始，github已经支持给自定义的域名加小绿锁了。真的是很无语，有一种「若不自宫，也能成功」的感觉…… ","date":"2018-05-29","objectID":"/posts/%E6%8A%98%E8%85%BE/%E5%8D%9A%E5%AE%A2%E5%8A%A0https/:2:0","tags":["https"],"title":"博客加小绿锁","uri":"/posts/%E6%8A%98%E8%85%BE/%E5%8D%9A%E5%AE%A2%E5%8A%A0https/"},{"categories":["Python"],"content":"实验室的任务，搬砖的日常。 ","date":"2018-05-04","objectID":"/posts/python/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%8A%A0%E5%AF%86%E8%AF%86%E5%88%AB/:0:0","tags":["coding"],"title":"网络流量加密识别","uri":"/posts/python/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%8A%A0%E5%AF%86%E8%AF%86%E5%88%AB/"},{"categories":["Python"],"content":"简单介绍 本来准备每个月好歹写一篇有那么一点点意义的博客，可是由于自己实在太懒了，搞得更新得实在很慢。 这篇博客没有打算写什么内容，主要内容都在下面放的链接里面了，网络流量加密识别这个比较简单的任务是实验室的师兄某个项目里面的一个需求，然后就交给我这个很菜的菜鸟来做了。 所谓的网络流量加密识别就是识别一段数据流是否加密，而是否加密的判断依据就是我们所要识别的数据流的信息熵是否在某个区间内，如果在这个区间内的话，那么我们就认为有多大可能是加密的，如果不在的话我们就认为该数据流没有加密。 ","date":"2018-05-04","objectID":"/posts/python/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%8A%A0%E5%AF%86%E8%AF%86%E5%88%AB/:1:0","tags":["coding"],"title":"网络流量加密识别","uri":"/posts/python/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%8A%A0%E5%AF%86%E8%AF%86%E5%88%AB/"},{"categories":["Python"],"content":"代码 因为我先是用Python来写的，后来师兄说代码要用C++来实现，所以这里给出两个版本。 Python版本里面的是对txt文件里面的数据进行识别，注意这里的数据格式要严格按照我提供的数据格式来，否则需要修改代码里面的数据读取方式。数据来自于我用wireshark进行抓包的数据，是16进制的形式，这个在数据处理那里要注意一下，整个实现的原理参考云盘里的资料。 # 产生随机的数据流(也就是标准的对照组) def generateDatastream(n, N): entropy = [] for i in range(n): data_stream = [] #每次清空这个数据流，重新生成 for j in range(N): F = random.randint(0, 256) data_stream.append(F) d = collections.Counter(data_stream) #得到一个数据流中每个字节出现的次数 H = 0 #计算一个数据流的字节熵 for k in d: m = (d[k] / N) * math.log(d[k] / N, 2) H = H + m H = -H entropy.append(H) mean_value = sum(entropy) / n #计算均值 standard_deviation = np.std(entropy)#计算标准差 #下面计算置信区间以及置信度 for y in list(range(1,6)): satisfy = 0 for en in entropy: low = mean_value - y * standard_deviation up = mean_value + y * standard_deviation if low \u003c= en \u003c= up: satisfy = satisfy + 1 confidence_level = satisfy / n * 100 if y == 4: low1 = low up1 = up confidence_level_1 = confidence_level return low1, up1, confidence_level_1 # 识别待检测的数据流，这里传入合适的置信区间 def recognizeDatastream(filename, N, low, up, confidence_level): fr = open(filename, 'r') arrayLines = fr.readlines() numLines = len(arrayLines) data_stream = [] for line in arrayLines: line = line.strip() line_1 = line.split('|') l = len(line_1) for i in list(range(l)): data_stream.append(line_1[i]) data = [] for k in list(range(N)): data_stream[k] = int(data_stream[k], 16) data.append(data_stream[k]) d = collections.Counter(data) H = 0 for k in d: m = (d[k] / N) * math.log(d[k] / N, 2) H = H + m H = -H print '待检测数据流的字节熵为: ' + str(H) if low \u003c= H \u003c= up: print '该数据流是加密的,置信度为:' + str(confidence_level) + '%' else: print '该数据流没有加密' C++版本1.0跟上面用Python实现的效果一样，也是对txt文件里面的数据进行加密识别，在这里就不贴代码了，贴一下C++1.0版本的代码，这里唯一的区别就是对于数据的读取有区别，2.0是直接读取整个文件，把文件当成数据流来读取，然后进行加密识别。 class Tools{ public: int string_to_hex(string\u0026 str) //transfer string to hex-string { int tmp = 0; for(int i = 0;i \u003c str.size();i++) { if(str[i] \u003e= '0' \u0026\u0026 str[i] \u003c= '9') tmp = tmp * 16 + str[i] - '0'; else if(str[i] \u003e= 'a' \u0026\u0026 str[i] \u003c= 'f') tmp = tmp * 16 + str[i] - 'a' + 10; else if(str[i] \u003e= 'A' \u0026\u0026 str[i] \u003c= 'F') tmp = tmp * 16 + str[i] - 'A' + 10; } return tmp; } vector\u003cstring\u003e splitEx(const string\u0026 src, string separate_character) { vector\u003cstring\u003e strs; int separate_characterLen = separate_character.size();//分割字符串的长度,这样就可以支持如“,,”多字符串的分隔符 int lastPosition = 0,index = -1; while (-1 != (index = src.find(separate_character,lastPosition))) { strs.push_back(src.substr(lastPosition,index - lastPosition)); lastPosition = index + separate_characterLen; } string lastString = src.substr(lastPosition);//截取最后一个分隔符后的内容 if (!lastString.empty()) strs.push_back(lastString);//如果最后一个分隔符后还有内容就入队 return strs; } }; class Recognize{ public: vector\u003cdouble\u003e result; //static double *result; Tools tl; public: Recognize(int n, int N){//n为生成数据流的个数，N为生成数据流的长度 vector\u003cdouble\u003e entropy; for(int i = 0; i \u003c n; i++){ int *data_stream = new int[N]; map\u003cint, int\u003e d; for(int j = 0; j \u003c N; j++){ int F = rand() % 255; data_stream[j] = F; d[F]++; } map\u003cint,int\u003e::iterator it; it = d.begin(); double H = 0; double m; while(it != d.end()){ m = (double(it-\u003esecond) / double(N)) * (log(double(it-\u003esecond) / double(N)) / double(log(2))); H = H + m; it++; } H = -H; entropy.push_back(H); } double sum = accumulate(begin(entropy), end(entropy), 0.0); double mean_value = sum / entropy.size(); //均值 //这里的标准差最后除以的数据是(size-1) double accum = 0.0; //计算标准差 for(int k = 0; k \u003c n; k++){ accum += pow(entropy[k] - mean_value,2); } double standard_deviation = pow(accum / (entropy.size()-1), 0.5); //下面计算置信区间和置信度,这里标准差的倍数我们取4 for(int y = 1; y \u003c 6; y++){ double satisfy = 0.0; double low = mean_value - double(y) * standard_deviation; double up = mean_value + double(y) * standard_deviation; for(int num = 0; num \u003c entropy.size(); num++){ //为了避免截断误差，这样比较大小 if(entropy[num] - low \u003e= 1e-10 \u0026\u0026 up - entropy[num] \u003e= 1e-10){ satisfy += 1; } } double confidence_level = satisfy / double(entropy.size()) * double(100); //打印不同置信度的置信区间 cout \u003c\u003c \"置信区间为: [\" \u003c\u003c low \u003c\u003c \",\" \u003c\u003c up \u003c\u003c \"]\" \u003c\u003c endl; cout \u003c\u003c \"置信度为: \" \u003c\u003c co","date":"2018-05-04","objectID":"/posts/python/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%8A%A0%E5%AF%86%E8%AF%86%E5%88%AB/:2:0","tags":["coding"],"title":"网络流量加密识别","uri":"/posts/python/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%8A%A0%E5%AF%86%E8%AF%86%E5%88%AB/"},{"categories":["Python"],"content":"后续…（5.28） 后续就是：加密的代码还要自己写，项目里面不是识别我测试的数据，识别的是二进制数据流，所以下面还要实现两个功能。 加密算法 16进制转2进制 1、加密算法我就直接从网上找然后改别人的，一共写了3种加密算法分别是DES，3DES，AES。开始写完的时候没有注意到密钥的问题，每次使用同一个密钥对数据进行加密，导致如果待检测二进制数据全为0的话，加密效果十分不好，随机性太弱。后来改进加密算法，因为这三个加密算法是对块进行加密的，那么我就将每一次对当前块的加密结果作为下一次的密钥，这样使得每次对块加密使用的密钥都不一样了，最终的加密效果就相当不错了，随机性很强。 2、16进制转2进制，这个就很基础了，没啥可说的，代码写得很暴力，就不贴了。 ","date":"2018-05-04","objectID":"/posts/python/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%8A%A0%E5%AF%86%E8%AF%86%E5%88%AB/:2:1","tags":["coding"],"title":"网络流量加密识别","uri":"/posts/python/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%8A%A0%E5%AF%86%E8%AF%86%E5%88%AB/"},{"categories":["Python"],"content":"资源 文件地址(百度网盘) 提取码：ajis ","date":"2018-05-04","objectID":"/posts/python/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%8A%A0%E5%AF%86%E8%AF%86%E5%88%AB/:3:0","tags":["coding"],"title":"网络流量加密识别","uri":"/posts/python/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%8A%A0%E5%AF%86%E8%AF%86%E5%88%AB/"},{"categories":null,"content":"若自己写的技术文档三个月之后乃至更长时间跨度，不能指导自己的相关工作，该文档严重不合格。该标准很靠谱，诸君可自行检验。 —SCZ ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"链接 离别歌 0xdf hacks stuff Huli’s blog Wiz Blog ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"摘录 比达成目标更重要的事，是建立好的学习系统，也就是习惯。 —网球优等生 学习没有失败，只有放弃。 —跑者如何以身练心 真正的英雄不是改变世界，而是改变自己生活的每一天。 —人类学家项飙 芝兰生于幽谷，不以无人而不芳 君子修身养德，不以穷困而改志 —耗子叔 人们习惯于惬意的麻木，大多数人都悄无声息地生活在绝望中。 苟有恒，何必三更眠五更起；最无益，莫过一日曝十日寒。心情不好，应该做的事情也要坚持去做，这样即使一天过去了，你该做的一件也没落下。 —Tinyfool 一周是一年的2% —Nat Friedman ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"}]